void _start () { if( thread == null ) { return; } int priority ; isClosed = false ; priority = Thread . currentThread () . getPriority () + 1 ; if ( priority > Thread . MAX_PRIORITY ) { priority = Thread . MAX_PRIORITY ; }
thread . setPriority ( priority ) ; thread . setDaemon ( true ) ; thread . start () ; threaded = true ; } private int __read ( final boolean mayBlock ) throws IOException { int ch ; while ( true ) {
if( ! mayBlock && super . available () == 0 ) { return WOULD_BLOCK ; } if ( ( ch = super . read () ) < 0 ) { return EOF ; } ch = ch & 0xff ; synchronized ( client ) { client . processAYTResponse () ;
} client . spyRead ( ch ) ; switch ( receiveState ) { case STATE_CR : if ( ch == '\0' ) { continue; } case STATE_DATA : if ( ch == TelnetCommand . IAC ) { receiveState = STATE_IAC ; continue; } if ( ch == '\r' ) {
synchronized ( client ) { if ( client . requestedDont ( TelnetOption . BINARY ) ) { receiveState = STATE_CR ; } else { receiveState = STATE_DATA ; } } } else { receiveState = STATE_DATA ; } break; case STATE_IAC : switch ( ch ) {
case TelnetCommand . WILL : receiveState = STATE_WILL ; continue; case TelnetCommand . WONT : receiveState = STATE_WONT ; continue; case TelnetCommand . DO : receiveState = STATE_DO ; continue; case TelnetCommand . DONT : receiveState = STATE_DONT ; continue; case TelnetCommand . SB : suboptionCount = 0 ;
receiveState = STATE_SB ; continue; case TelnetCommand . IAC : receiveState = STATE_DATA ; break; case TelnetCommand . SE : receiveState = STATE_DATA ; continue; default: receiveState = STATE_DATA ; client . processCommand ( ch ) ; continue; } break; case STATE_WILL : synchronized ( client ) {
client . processWill ( ch ) ; client . flushOutputStream () ; } receiveState = STATE_DATA ; continue; case STATE_WONT : synchronized ( client ) { client . processWont ( ch ) ; client . flushOutputStream () ; } receiveState = STATE_DATA ; continue; case STATE_DO :
synchronized ( client ) { client . processDo ( ch ) ; client . flushOutputStream () ; } receiveState = STATE_DATA ; continue; case STATE_DONT : synchronized ( client ) { client . processDont ( ch ) ; client . flushOutputStream () ; } receiveState = STATE_DATA ; continue;
case STATE_SB : switch ( ch ) { case TelnetCommand . IAC : receiveState = STATE_IAC_SB ; continue; default: if ( suboptionCount < suboption . length ) { suboption [ suboptionCount ++ ] = ch ; } break; } receiveState = STATE_SB ; continue; case STATE_IAC_SB :
switch ( ch ) { case TelnetCommand . SE : synchronized ( client ) { client . processSuboption ( suboption , suboptionCount ) ; client . flushOutputStream () ; } receiveState = STATE_DATA ; continue; case TelnetCommand . IAC : if ( suboptionCount < suboption . length ) {
suboption [ suboptionCount ++ ] = ch ; } break; default: break; } receiveState = STATE_SB ; continue; } break; } return ch ; } private boolean processChar ( final int ch ) throws InterruptedException { boolean bufferWasEmpty ; synchronized ( queue ) { bufferWasEmpty = bytesAvailable == 0 ;
while ( bytesAvailable >= queue . length - 1 ) { if( threaded ) { queue . notify () ; try { queue . wait () ; } catch ( final InterruptedException e ) { throw e ; } } else { throw new IllegalStateException ( lr_1 ) ; }
} if ( readIsWaiting && threaded ) { queue . notify () ; } queue [ queueTail ] = ch ; ++ bytesAvailable ; if ( ++ queueTail >= queue . length ) { queueTail = 0 ; } } return bufferWasEmpty ; } @Override
public int read () throws IOException { synchronized ( queue ) { while ( true ) { if ( ioException != null ) { IOException e ; e = ioException ; ioException = null ; throw e ; } if ( bytesAvailable == 0 ) {
if ( hasReachedEOF ) { return EOF ; } if( threaded ) { queue . notify () ; try { readIsWaiting = true ; queue . wait () ; readIsWaiting = false ; } catch ( final InterruptedException e ) { throw new InterruptedIOException ( lr_2 ) ; } }
else { readIsWaiting = true ; int ch ; boolean mayBlock = true ; do { try { if ( ( ch = __read ( mayBlock ) ) < 0 ) { if( ch != WOULD_BLOCK ) { return ch ; } } } catch ( final InterruptedIOException e )
{ synchronized ( queue ) { ioException = e ; queue . notifyAll () ; try { queue . wait ( 100 ) ; } catch ( final InterruptedException interrupted ) { } } return EOF ; } try { if( ch != WOULD_BLOCK ) {
processChar ( ch ) ; } } catch ( final InterruptedException e ) { if ( isClosed ) { return EOF ; } } mayBlock = false ; } while ( super . available () > 0 && bytesAvailable < queue . length - 1 ); readIsWaiting = false ;
} continue; } int ch ; ch = queue [ queueHead ] ; if ( ++ queueHead >= queue . length ) { queueHead = 0 ; } -- bytesAvailable ; if( bytesAvailable == 0 && threaded ) { queue . notify () ; } return ch ; } }
} @Override public int read ( final byte buffer [] ) throws IOException { return read ( buffer , 0 , buffer . length ) ; } @Override public int read ( final byte buffer [] , int offset , int length ) throws IOException {
int ch , off ; if ( length < 1 ) { return 0 ; } synchronized ( queue ) { if ( length > bytesAvailable ) { length = bytesAvailable ; } } if ( ( ch = read () ) == EOF ) { return EOF ; }
off = offset ; do { buffer [ offset ++ ] = ( byte ) ch ; } while ( -- length > 0 && ( ch = read () ) != EOF ); return offset - off ; } @Override public boolean markSupported () { return false ; }
@Override public int available () throws IOException { synchronized ( queue ) { if ( threaded ) { return bytesAvailable ; } return bytesAvailable + super . available () ; } } @Override public void close () throws IOException { super . close () ; synchronized ( queue ) {
hasReachedEOF = true ; isClosed = true ; if ( thread != null && thread . isAlive () ) { thread . interrupt () ; } queue . notifyAll () ; } } @Override public void run () { int ch ; try { _outerLoop: while ( ! isClosed )
{ try { if ( ( ch = __read ( true ) ) < 0 ) { break; } } catch ( final InterruptedIOException e ) { synchronized ( queue ) { ioException = e ; queue . notifyAll () ; try { queue . wait ( 100 ) ;
} catch ( final InterruptedException interrupted ) { if ( isClosed ) { break _outerLoop; } } continue; } } catch( final RuntimeException re ) { super . close () ; break _outerLoop; } boolean notify = false ; try { notify = processChar ( ch ) ; }
catch ( final InterruptedException e ) { if ( isClosed ) { break _outerLoop; } } if ( notify ) { client . notifyInputListener () ; } } } catch ( final IOException ioe ) { synchronized ( queue ) { ioException = ioe ; }
client . notifyInputListener () ; } synchronized ( queue ) { isClosed = true ; hasReachedEOF = true ; queue . notify () ; } threaded = false ; }
